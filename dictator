#! /usr/local/bin/python3

from subprocess import call
import random
import json
import shelve
from contextlib import closing
import curses


class Dictator:
    list = []
    dictionary = {}
    user_config = {'score': 0, 'level': 0}
    word_base_len = 6
    index = 0
    score = 0

    def __init__(self, number_of_words=10):
        self. number_of_words = number_of_words
        self.dictionary = json.load(open('./assets/dictionary-lc.json', 'r'))
        with closing(shelve.open('./data/user_shelf.db')) as s:
            if (s.get('default_user')):
                self.user_config = s.get('default_user')

        word_list = open('./assets/wordlist.txt', 'r')
        for word in word_list:
            if self.word_for_level(word):
                self.list.append(str.strip(word))
        word_list.close()

        random.shuffle(self.list)
        self.list = self.list[0:self.number_of_words]

    def play(self):
        if (self.index >= len(self.list)):
            updated_score = self.user_config.get('score') + self.score
            updated_level = None
            if (updated_score != self.user_config.get('score') and
                    updated_score % 10 == 0):
                updated_level = self.user_config.get('level') + 1

            self.update_user_config(score=updated_score, level=updated_level)

        cur_word = self.list[self.index]
        call(['say', cur_word])
        call(['say', self.dictionary[cur_word]])
        call(['say', cur_word])
        self.index += 1

    def check_word(self, input_word):
        cur_word = self.list[self.index]
        if(str.lower(input_word) == str.lower(cur_word)):
            return (True, cur_word, input_word)
        else:
            return (False, cur_word, input_word, self.dictionary[cur_word])

    def update_user_config(self, score=None, level=None, words_seen=None):
        with closing(shelve.open('./data/user_shelf.db')) as s:
            if score:
                self.user_config['score'] = score
            if level:
                self.user_config['level'] = level
            if words_seen:
                self.user_config['words_seen'] = words_seen
            s['default_user'] = self.user_config

    def word_for_level(self, word):
        user_level = self.user_config.get('level')
        return len(word) < (self.word_base_len + user_level) and \
            len(word) > self.user_config.get('level')


def draw_game(stdscr):
    k = 0
    cursor_x = 0
    cursor_y = 0
    first_run = True
    dictator = Dictator()
    # Clear and refresh the screen for a blank canvas
    stdscr.clear()
    stdscr.refresh()

    # Start colors in curses
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)

    typed_word = ""
    # Loop where k is the last character pressed
    while (k != 27):

        # Initialization
        stdscr.clear()
        height, width = stdscr.getmaxyx()

       
        # Declaration of strings
        title = "Dictator"[:width-1]
        subtitle = "Written by Aaron Goshine"[:width-1]
        expected = "Expected word: {}".format(k)[:width-1]
        supplied = "Supplied word: {}".format(typed_word)[:width-1]
        how_to_play = "Please listen carefully and type the words you hear"

        statusbarstr = "Press 'esc' to exit | SCORE: {}".format(cursor_y)

        # Centering calculations
        start_x_title = int((width // 2) - (len(title) //
                                            2) - len(title) % 2)

        start_x_subtitle = int((width // 2) - (len(subtitle) //
                                               2) - len(subtitle) % 2)

        start_x_expected = int((width // 2) - (len(expected) //
                                               2) - len(expected) % 2)

        start_x_supplied = int((width // 2) - (len(supplied) //
                                               2) - len(supplied) % 2)

        start_x_how_to = int((width // 2) - (len(how_to_play) //
                                             2) - len(how_to_play) % 2)
        start_y = int((height // 2) - 2)

        # Rendering some text
        whstr = "level: {}, top score: {}".format(width, height)
        stdscr.addstr(0, 0, whstr, curses.color_pair(1))

        # Render status bar
        stdscr.attron(curses.color_pair(3))
        stdscr.addstr(height-1, 0, statusbarstr)
        stdscr.addstr(height-1, len(statusbarstr), " " * (width - len(
            statusbarstr) - 1))
        stdscr.attroff(curses.color_pair(3))

        # Turning on attributes for title
        stdscr.attron(curses.color_pair(2))
        stdscr.attron(curses.A_BOLD)

        # Rendering title
        stdscr.addstr(start_y, start_x_title, title)

        # Turning off attributes for title
        stdscr.attroff(curses.color_pair(2))
        stdscr.attroff(curses.A_BOLD)

        # Print rest of text
        stdscr.addstr(start_y + 1, start_x_subtitle, subtitle)
        stdscr.addstr(start_y + 3, (width // 2) - 2, '-' * 8)
        stdscr.addstr(start_y + 5, start_x_how_to, how_to_play)

        stdscr.addstr(start_y + 8, start_x_expected, expected)
        stdscr.addstr(start_y + 9, start_x_supplied, supplied)
        stdscr.move(cursor_y, cursor_x)

        # Refresh the screen
        stdscr.refresh()

        if k == 10:
            played = dictator.check_word(typed_word)
            if (played[0]):
                expected = 'Well done'
            else:
                expected = 'try again'
            dictator.play()

        if k == 0:
            dictator.play()

        # Wait for next input
        k = stdscr.getch()

        if k >= 97 and k <= 172:
            typed_word = typed_word + chr(k)


def main():
    # dictator = Dictator()
    # dictator.play()
    #
    curses.wrapper(draw_game)


if __name__ == '__main__':
    main()
