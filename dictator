#! /usr/local/bin/python3

from subprocess import call
from contextlib import closing
import random
import json
import shelve
import time
import os
import sys


class Dictator:
    list = []
    dictionary = {}
    user_config = {'score': 0, 'level': 0}
    word_base_len = 6
    current_word = ''

    index = 0
    score = 0
    stage_width = 0

    def __init__(self, number_of_words=10, stage_width=80):
        self. number_of_words = number_of_words
        self. stage_width = stage_width
        self.dictionary = json.load(open('./assets/dictionary-lc.json', 'r'))
        with closing(shelve.open('./data/user_shelf.db')) as s:
            if (s.get('default_user')):
                self.user_config = s.get('default_user')

        word_list = open('./assets/wordlist.txt', 'r')
        for word in word_list:
            if self.word_for_level(word):
                self.list.append(str.strip(word))
        word_list.close()

        random.shuffle(self.list)
        self.list = iter(self.list[0:self.number_of_words])

    def next_word(self):
        try:
            self.current_word = next(self.list)
        except StopIteration:
            self.current_word = None
            return False
        return True

    def play(self):
        if (self.current_word):
            call(['say', self.current_word])
            return True

    def play_definition(self):
        if (self.current_word):
            call(['say', self.dictionary[self.current_word]])
        return True

    def check_word(self, input_word):
        if (not self.current_word):
            return None
        current_meaning = self.dictionary[self.current_word]
        is_correct = (str.lower(input_word) == str.lower(self.current_word))
        if is_correct:
            updated_score = self.user_config.get('score') + 1
            updated_level = None
            if (updated_score != self.user_config.get('score') and
                    updated_score % 10 == 0):
                    updated_level = self.user_config.get('level') + 1
            self.update_user_config(score=updated_score, level=updated_level)
        return [is_correct, self.current_word, input_word, current_meaning]

    def update_user_config(self, score=None, level=None, words_seen=None):
        with closing(shelve.open('./data/user_shelf.db')) as s:
            if score:
                self.user_config['score'] = score
            if level:
                self.user_config['level'] = level
            if words_seen:
                self.user_config['words_seen'] = words_seen
            s['default_user'] = self.user_config

    def get_user(self):
        return self.user_config

    def word_for_level(self, word):
        user_level = self.user_config.get('level')
        return len(word) < (self.word_base_len + user_level) and \
            len(word) > self.user_config.get('level')


def draw_game():
    dictator = Dictator()
    expected_word = ""
    supplied_word = ""
    message = ""
    runing = True
    current_definition = ""

    def red(text):
        return '\033[1;31m{}\033[0m'.format(text)

    def green(text):
        return '\033[1;32m{}\033[0m'.format(text)

    def blink(text):
        return '\033[5m{}\033[0m'.format(text)

    def yellow(text):
        return '\033[0;33m{}\033[0m'.format(text)

    def notice(text):
        return '\033[0;30;47m{}\033[0m'.format(text)

    while (runing):
        _, w = os.popen('stty size', 'r').read().split()
        width = int(w)
        os.system('clear')

        user = dictator.get_user()
        # Declaration of strings
        hud = " LEVEL: {}, TOP SCORE: {}".format(user['level'], user['score'])
        title = "DICTATOR \n"
        subtitle = "Written by Aaron Goshine \n"
        how_to_play = "Please listen carefully and type the words you hear\n"
        expected = "Expected word: {}".format(expected_word)
        supplied = "Supplied word: {}".format(supplied_word)
        definition = "Definition: {}".format(current_definition)

        # Rendering some text
        print(notice(hud.ljust(width - 1, ' ')))
        print(title.center(width, ' '))
        print(subtitle.center(width, ' '))
        print(('-' * (width // 2)).center(width, ' '))
        print(how_to_play.center(width, ' '))
        print(expected.center(width, ' '))
        print(supplied.center(width, ' '))
        print('\n')
        print(yellow(definition.center(width, ' ')))
        print('\n')
        print(message)

        # Refresh the screen
        has_word = dictator.next_word()
        dictator.play()
        d = yellow('d')
        c = yellow('c')
        r = yellow('r')
        y = green('y')
        n = red('n')

        prompt = 'Choose [{}]efinition, [{}]epeat, [{}]ontinue | word: '.format(d, r, c)

        if has_word:
            ans = str.strip(str(input(prompt)))

        while ans in ['d','r']:
            if (str.lower(ans) == 'd'):
                dictator.play_definition()
                dictator.play()

            if (str.lower(ans) == 'r'):
                dictator.play()
            ans = str.strip(str(input(prompt)))

        typed_word = ans

        if not has_word:
            ans = str.strip(str(input('Continue playing? [{}]/[{}] :'.format(y, n))))
            if(str.lower(ans) == 'y'):
                dictator = Dictator()
                has_word = dictator.next_word()
                dictator.play()
                typed_word = str.strip(str(input('Word?: ')))
            else:
                runing = False
                print(blink(('-' * (width // 2)).center(width, ' ')))
                print(yellow('!!!Catch yooo later!!!'.center(width, ' ')))
                print(blink(('-' * (width // 2)).center(width, ' ')))
                break

        results = dictator.check_word(typed_word)

        if (results):
            if (results[0]):
                message = green('Well done'.center(width, ' '))
            else:
                message = red('Try again!'.center(width, ' '))
        expected_word = results[1]
        supplied_word = results[2]
        current_definition = results[3]


def main():
    draw_game()


if __name__ == '__main__':
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        os.system('clear')
        sys.exit()
